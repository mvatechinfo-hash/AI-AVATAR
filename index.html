<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-AVATAR</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <!-- Three.js and GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tone.js for audio -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.js"></script>

    <!-- Inter Font and custom styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background: #111827;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        canvas {
            display: block;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        .chat-ui-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            top: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            background-color: rgba(31, 41, 55, 0.9);
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .chat-ui-container.collapsed {
            width: 60px;
            height: 60px;
            bottom: 20px;
            right: 20px;
            top: auto;
            border-radius: 9999px;
            padding: 0;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
            -ms-overflow-style: none;
            scrollbar-width: none;
            display: flex;
            flex-direction: column-reverse;
        }

        .chat-messages::-webkit-scrollbar {
            display: none;
        }

        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.75rem;
            word-wrap: break-word;
        }

        .user-message {
            background-color: #3B82F6;
            color: white;
            margin-left: auto;
            max-width: 80%;
            border-bottom-right-radius: 0;
        }

        .bot-message {
            background-color: #4B5563;
            color: white;
            margin-right: auto;
            max-width: 80%;
            border-bottom-left-radius: 0;
        }

        .input-container {
            display: flex;
            padding-top: 1rem;
        }

        .input-field {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #4B5563;
            background-color: #374151;
            color: white;
            margin-right: 0.5rem;
        }

        .input-field:focus {
            outline: none;
            border-color: #6B7280;
        }

        .action-button {
            background-color: #3B82F6;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: #2563EB;
        }

        .action-button.mic-button {
            background-color: #EF4444;
        }

        .action-button.mic-button:hover {
            background-color: #DC2626;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .control-button {
            width: 48px;
            height: 48px;
            background: rgba(31, 41, 55, 0.9);
            border: 1px solid #4B5563;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .control-button:hover {
            background: rgba(55, 65, 81, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111827;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #3B82F6;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .listening-pulse {
            animation: pulse-border 1.5s infinite;
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
            }
        }
        
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(31, 41, 55, 0.95);
            padding: 2rem;
            border-radius: 1rem;
            color: white;
            text-align: center;
            z-index: 20;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .voice-selector-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner mb-4"></div>
        <div id="loading-text">Loading... 0%</div>
    </div>

    <!-- Chat UI -->
    <div class="chat-ui-container" id="chat-ui-container">
        <div class="flex justify-between items-center p-2 rounded-t-xl cursor-pointer bg-gray-700" id="chat-header">
            <span class="text-white font-bold">Chat with AI</span>
            <button id="close-chat" class="text-white hover:text-gray-400 focus:outline-none">
                <i class="fas fa-minus"></i>
            </button>
        </div>
        <div class="chat-messages p-4" id="chat-messages">
            <!-- Messages will be appended here -->
        </div>
        <div class="input-container p-4">
            <input type="text" id="chat-input" class="input-field rounded-full" placeholder="Type a message...">
            <button id="mic-button" class="action-button mic-button rounded-full">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="send-button" class="action-button rounded-full ml-2">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>

    <!-- Control Buttons -->
    <div class="control-buttons">
        <button id="dance-button" class="control-button">
            <i class="fas fa-music"></i>
        </button>
    </div>

    <!-- Custom Message Box -->
    <div id="message-box" class="message-box">
        <p id="message-box-text"></p>
        <button id="message-box-close" class="mt-4 px-4 py-2 bg-blue-500 rounded-lg">OK</button>
    </div>

    <!-- JavaScript logic -->
    <script type="module">
        // API key and model name
        const API_KEY = "AIzaSyCWaPLRukI_Rhb8vB29vVjEk5GEuopXnA4";
        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";

        // Global variables for Three.js
        let scene, camera, renderer, controls;
        let avatar, mixer;
        let animations = {};
        let animationNames = {
            idle: 'idle',
            idle2: 'idle2',
            walk: 'walk',
            talk: 'talk',
            wave: 'wave',
            dance: 'dance',
            think: 'think',
            shake: 'shake',
            listen: 'listen'
        };
        let clock = new THREE.Clock();
        let jawBone;
        let isTalking = false;
        let isMoving = false;
        let isTurning = false;
        let targetQuaternion = new THREE.Quaternion();
        let turnStartTime;
        const turnDuration = 500; // ms

        // Global variables for chat and interaction
        let chatHistory = [];
        let recognition;
        let audioContext;
        let idleTimer, passiveIdleTimer, patrolTimer;
        const IDLE_TIME = 10000;
        const PASSIVE_IDLE_TIME = 20000;
        const PATROL_INTERVAL = 10000;
        let currentIdleState = 'active';
        let maleVoice; // Web Speech API voice
        let isDancing = false;
        let isSpeaking = false;
        let isListening = false;
        let lastInteractionTime = Date.now();

        // HTML elements
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const chatMessages = document.getElementById('chat-messages');
        const micButton = document.getElementById('mic-button');
        const danceButton = document.getElementById('dance-button');
        const chatUIContainer = document.getElementById('chat-ui-container');
        const closeChatButton = document.getElementById('close-chat');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const messageBox = document.getElementById('message-box');
        const messageBoxText = document.getElementById('message-box-text');
        const messageBoxClose = document.getElementById('message-box-close');
        
        // Tone.js variables
        let synth, loop;

        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 6;
            controls.minPolarAngle = Math.PI / 4;
            controls.maxPolarAngle = Math.PI / 2;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(2, 5, 3);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.ShadowMaterial({
                opacity: 0.5
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            // Load 3D model
            const loader = new THREE.GLTFLoader();

            // Loading Manager to track progress
            const loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(url, loaded, total) {
                const progress = Math.round((loaded / total) * 100);
                loadingText.innerText = `Loading... ${progress}%`;
            };

            loadingManager.onLoad = function() {
                // Hide loading screen after all assets are loaded
                setTimeout(() => {
                    loadingScreen.style.opacity = 0;
                    loadingScreen.addEventListener('transitionend', () => loadingScreen.remove());
                    // Start the idle sequence and greeting
                    resetIdleTimers();
                    playGreeting();
                }, 500);
            };

            const glbFiles = {
                idle: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/idle.glb',
                idle2: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/idle2.glb',
                walk: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/walk.glb',
                talk: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/talk.glb',
                wave: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/wave.glb',
                dance: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/dance.glb',
                think: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/think.glb',
                shake: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/shake.glb',
                listen: 'https://raw.githubusercontent.com/ajh-dev/avatars/main/animations/listen.glb'
            };

            // Load each animation file and store its data
            let loadedCount = 0;
            const totalFiles = Object.keys(glbFiles).length;

            for (const name in glbFiles) {
                loader.load(glbFiles[name], function(gltf) {
                    if (name === 'idle') {
                        avatar = gltf.scene;
                        avatar.scale.set(0.7, 0.7, 0.7);
                        avatar.position.y = 0;
                        avatar.castShadow = true;
                        scene.add(avatar);

                        // Find the jaw bone for lip-syncing
                        avatar.traverse(o => {
                            if (o.isMesh) {
                                o.castShadow = true;
                                o.receiveShadow = true;
                            }
                            if (o.name === 'mixamorigJaw') {
                                jawBone = o;
                            }
                        });

                        mixer = new THREE.AnimationMixer(avatar);
                    }
                    animations[name] = gltf.animations[0];
                    loadedCount++;
                    const progress = Math.round((loadedCount / totalFiles) * 100);
                    loadingManager.onProgress('', loadedCount, totalFiles);
                }, undefined, function(error) {
                    console.error('An error happened during loading:', error);
                });
            }

            // Web Speech API Voice Selection
            window.speechSynthesis.onvoiceschanged = () => {
                const voices = window.speechSynthesis.getVoices();
                maleVoice = voices.find(voice => voice.name.includes("Male") || voice.name.includes("Google US English"));
            };

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);

            animate();
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle mouse movement for mouse-look
        function onMouseMove(event) {
            if (!avatar) return;
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            const target = new THREE.Vector3(pos.x, avatar.position.y + 1.2, pos.z);
            avatar.lookAt(target);
        }

        // Handle mouse click on ground for movement
        function onDocumentMouseDown(event) {
            resetIdleTimers();
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.object.geometry.type === 'PlaneGeometry') {
                    moveAvatarTo(intersect.point);
                }
            }
        }

        // Move avatar to a new position
        function moveAvatarTo(targetPosition) {
            if (!avatar || isDancing || isSpeaking || isListening) return;
            
            isMoving = true;
            avatar.userData.targetPosition = targetPosition;

            // Face the new target position before moving
            const direction = new THREE.Vector3().subVectors(targetPosition, avatar.position).normalize();
            const angle = Math.atan2(direction.x, direction.z);
            targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);

            isTurning = true;
            turnStartTime = Date.now();
            playAction(animationNames.walk, THREE.LoopRepeat);
        }

        // Play an animation action
        function playAction(name, loopMode = THREE.LoopOnce) {
            if (!mixer || !animations[name]) return;

            mixer.stopAllAction();
            const action = mixer.clipAction(animations[name]);
            action.setLoop(loopMode);
            action.clampWhenFinished = true;
            action.play();
            return action;
        }

        // Animate loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Lip-syncing
            if (isTalking && jawBone) {
                const time = Date.now() * 0.005;
                const jawRotation = Math.sin(time) * 0.05 + 0.02;
                jawBone.rotation.x = -jawRotation;
            } else if (jawBone) {
                jawBone.rotation.x = 0;
            }
            
            // Movement logic
            if (isMoving && avatar) {
                const distance = avatar.position.distanceTo(avatar.userData.targetPosition);

                if (distance > 0.05) {
                    if (isTurning) {
                        const elapsedTime = Date.now() - turnStartTime;
                        const turnProgress = Math.min(elapsedTime / turnDuration, 1);
                        avatar.quaternion.slerp(targetQuaternion, turnProgress);
                        if (turnProgress >= 1) {
                            isTurning = false;
                        }
                    } else {
                        const direction = new THREE.Vector3().subVectors(avatar.userData.targetPosition, avatar.position).normalize();
                        avatar.position.addScaledVector(direction, 0.008);
                    }
                } else {
                    avatar.position.copy(avatar.userData.targetPosition);
                    isMoving = false;
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                    lastInteractionTime = Date.now();
                }
            }

            // Idle and Patrol logic
            if (!isMoving && !isSpeaking && !isDancing && !isListening) {
                const currentTime = Date.now();
                if (currentIdleState === 'active' && currentTime - lastInteractionTime > IDLE_TIME) {
                    playAction(animationNames.idle, THREE.LoopRepeat);
                    currentIdleState = 'passive';
                    lastInteractionTime = currentTime;
                } else if (currentIdleState === 'passive' && currentTime - lastInteractionTime > PASSIVE_IDLE_TIME) {
                    startPatrol();
                    currentIdleState = 'patrol';
                    lastInteractionTime = currentTime;
                }
            }
            
            if (mixer) mixer.update(delta);
            controls.update();
            renderer.render(scene, camera);
        }

        // Reset all idle timers and animations
        function resetIdleTimers() {
            clearTimeout(idleTimer);
            clearTimeout(passiveIdleTimer);
            clearInterval(patrolTimer);
            lastInteractionTime = Date.now();
            if (currentIdleState !== 'active' && !isSpeaking && !isMoving && !isDancing && !isListening) {
                playAction(animationNames.idle2, THREE.LoopRepeat);
            }
            currentIdleState = 'active';
            isMoving = false;
        }

        // Start patrol mode
        function startPatrol() {
            clearInterval(patrolTimer);
            patrolTimer = setInterval(() => {
                const x = Math.random() * 8 - 4;
                const z = Math.random() * 8 - 4;
                moveAvatarTo(new THREE.Vector3(x, 0, z));
            }, PATROL_INTERVAL);
        }

        // Show a custom message box
        function showMessageBox(message) {
            messageBoxText.innerText = message;
            messageBox.style.display = 'block';
        }

        // Handle closing the message box
        messageBoxClose.onclick = () => {
            messageBox.style.display = 'none';
        };

        // Handle avatar facing forward on interaction
        function faceForward() {
            if (!avatar) return;
            const fixedPosition = new THREE.Vector3(0, 0, 0);
            const cameraPosition = new THREE.Vector3(0, 1.5, 3);

            avatar.position.copy(fixedPosition);
            avatar.rotation.y = Math.PI;

            camera.position.copy(cameraPosition);
            camera.lookAt(fixedPosition);
        }

        // Event listeners for UI elements
        chatUIContainer.addEventListener('click', (event) => {
            event.stopPropagation();
            if (chatUIContainer.classList.contains('collapsed')) {
                chatUIContainer.classList.remove('collapsed');
                closeChatButton.innerHTML = '<i class="fas fa-minus"></i>';
                faceForward();
                playGreeting();
            }
            resetIdleTimers();
        });

        chatHeader.addEventListener('click', (event) => {
            event.stopPropagation();
            if (chatUIContainer.classList.contains('collapsed')) {
                chatUIContainer.classList.remove('collapsed');
                closeChatButton.innerHTML = '<i class="fas fa-minus"></i>';
                faceForward();
                playGreeting();
            }
            resetIdleTimers();
        });

        closeChatButton.addEventListener('click', (event) => {
            event.stopPropagation();
            chatUIContainer.classList.toggle('collapsed');
            if (chatUIContainer.classList.contains('collapsed')) {
                closeChatButton.innerHTML = '<i class="fas fa-comment"></i>';
            } else {
                closeChatButton.innerHTML = '<i class="fas fa-minus"></i>';
            }
        });
        
        // Greeting Logic
        async function playGreeting() {
            const greetings = ["Hello there!", "Hi!", "Hey!", "Greetings!"];
            const followups = ["What can I do for you?", "How can I help?", "Nice to see you!", "Feel free to ask me anything."];
            const greetingText = `${greetings[Math.floor(Math.random() * greetings.length)]} ${followups[Math.floor(Math.random() * followups.length)]}`;

            playAction(animationNames.wave);
            await new Promise(resolve => setTimeout(resolve, 1500)); // Wait for wave to finish
            textToSpeech(greetingText);
        }

        // Handle chat input
        chatInput.addEventListener('keydown', async (event) => {
            if (event.key === 'Enter') {
                const userMessage = chatInput.value.trim();
                if (userMessage) {
                    resetIdleTimers();
                    faceForward();
                    appendMessage('user', userMessage);
                    chatInput.value = '';
                    await getBotResponse(userMessage);
                }
            }
        });

        sendButton.addEventListener('click', async () => {
            const userMessage = chatInput.value.trim();
            if (userMessage) {
                resetIdleTimers();
                faceForward();
                appendMessage('user', userMessage);
                chatInput.value = '';
                await getBotResponse(userMessage);
            }
        });

        // Append messages to the chat UI
        function appendMessage(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
            messageElement.textContent = text;
            chatMessages.prepend(messageElement);
        }

        // Get bot response from Gemini API
        async function getBotResponse(userMessage) {
            // Check for a trigger word for dance mode
            if (userMessage.toLowerCase().includes('dance')) {
                dance(); // Call the dance function
                return; // Exit early so we don't get a chat response
            }

            isSpeaking = true;
            playAction(animationNames.think, THREE.LoopRepeat);

            try {
                chatHistory.push({
                    role: "user",
                    parts: [{
                        text: userMessage
                    }]
                });

                const payload = {
                    contents: chatHistory
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TEXT_MODEL}:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                const result = await response.json();
                let botResponseText = 'I am unable to generate a response at this time. Please try again.';
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    botResponseText = result.candidates[0].content.parts[0].text;
                }

                chatHistory.push({
                    role: "model",
                    parts: [{
                        text: botResponseText
                    }]
                });

                appendMessage('bot', botResponseText);
                textToSpeech(botResponseText);
            } catch (error) {
                console.error('Error generating text:', error);
                playAction(animationNames.shake);
                isSpeaking = false;
                setTimeout(() => {
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                }, 2000);
            }
        }
        
        // Text to Speech logic (using Web Speech API)
        function textToSpeech(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                
                if (maleVoice) {
                    utterance.voice = maleVoice;
                }

                utterance.onstart = () => {
                    isSpeaking = true;
                    isTalking = true;
                    playAction(animationNames.talk, THREE.LoopRepeat);
                };

                utterance.onend = () => {
                    isSpeaking = false;
                    isTalking = false;
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                    resetIdleTimers();
                };

                window.speechSynthesis.speak(utterance);
            } else {
                console.error("Speech Synthesis not supported");
            }
        }
        
        // Speech Recognition
        micButton.addEventListener('click', () => {
            if (isListening) {
                recognition.stop();
                micButton.classList.remove('listening-pulse');
                isListening = false;
                // Transition back to idle after stopping listening
                playAction(animationNames.idle2, THREE.LoopRepeat);
                return;
            }

            if (!('webkitSpeechRecognition' in window)) {
                showMessageBox("Speech recognition is not supported in this browser. Please use Chrome.");
                return;
            }
            
            faceForward();
            resetIdleTimers();

            // First, speak the prompt, then start listening
            const listeningUtterance = new SpeechSynthesisUtterance("Go ahead, I'm listening.");
            if (maleVoice) {
                listeningUtterance.voice = maleVoice;
            }
            listeningUtterance.onstart = () => {
                isSpeaking = true;
                playAction(animationNames.talk, THREE.LoopRepeat);
            }
            listeningUtterance.onend = () => {
                isSpeaking = false;
                startSpeechRecognition();
            }

            window.speechSynthesis.speak(listeningUtterance);
        });

        function startSpeechRecognition() {
            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isListening = true;
                micButton.classList.add('listening-pulse');
                playAction(animationNames.listen, THREE.LoopRepeat);
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                if (transcript) {
                    appendMessage('user', transcript);
                    getBotResponse(transcript);
                }
            };

            recognition.onend = () => {
                isListening = false;
                micButton.classList.remove('listening-pulse');
                // The getBotResponse will handle the idle animation after its done.
                // If the user said nothing, reset to idle here.
                if (!chatInput.value && !isSpeaking) {
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                isListening = false;
                micButton.classList.remove('listening-pulse');
                playAction(animationNames.shake);
                setTimeout(() => {
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                }, 2000);
            };

            recognition.start();
        }

        // Dance Mode
        function dance() {
            resetIdleTimers();
            faceForward();
            isDancing = true;
            
            if (Tone.Transport.state !== 'started') {
                Tone.start();
                synth = new Tone.Synth().toDestination();
                loop = new Tone.Loop(time => {
                    synth.triggerAttackRelease("C4", "8n", time);
                    synth.triggerAttackRelease("E4", "8n", time + Tone.Time("8n").toSeconds());
                    synth.triggerAttackRelease("G4", "8n", time + Tone.Time("4n").toSeconds());
                    synth.triggerAttackRelease("B4", "8n", time + Tone.Time("4n").toSeconds() + Tone.Time("8n").toSeconds());
                }, "2n").start(0);

                Tone.Transport.bpm.value = 120;
                Tone.Transport.start();
            }
            
            const danceAction = playAction(animationNames.dance, THREE.LoopOnce);

            danceAction.onFinished(() => {
                isDancing = false;
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    loop.dispose();
                    synth.dispose();
                }
                playAction(animationNames.idle2, THREE.LoopRepeat);
            });
        }
        
        danceButton.addEventListener('click', () => {
            faceForward();
            dance();
        });


        // Initialize on window load
        window.onload = function() {
            init();
        };

    </script>
</body>

</html>
