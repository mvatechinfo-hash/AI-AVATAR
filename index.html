import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { MeshLine, MeshLineMaterial } from 'meshline';
import * as Tone from 'tone';

// Main App component
export default function App() {
    // Refs for DOM elements and Three.js objects
    const mountRef = useRef(null);
    const avatarRef = useRef(null);
    const mixerRef = useRef(null);
    const clockRef = useRef(new THREE.Clock());
    const animationsRef = useRef({});
    const lookAtMouseRef = useRef(false);
    const audioSynthRef = useRef(null);
    const audioLoopRef = useRef(null);
    const isDancingRef = useRef(false);

    // State for UI elements and application logic
    const [chatHistory, setChatHistory] = useState([]);
    const [inputValue, setInputValue] = useState('');
    const [isThinking, setIsThinking] = useState(false);
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isListening, setIsListening] = useState(false);
    const [isAvatarLoaded, setIsAvatarLoaded] = useState(false);
    const [isMoving, setIsMoving] = useState(false);
    const [message, setMessage] = useState(null);

    // Three.js Scene, Camera, and Renderer
    const scene = useRef(new THREE.Scene());
    const camera = useRef(new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000));
    const renderer = useRef(new THREE.WebGLRenderer({ antialiasing: true }));
    const controls = useRef(null);

    // Raycaster for mouse interactions
    const raycaster = useRef(new THREE.Raycaster());
    const mouse = useRef(new THREE.Vector2());

    // Auto-patrol variables
    const lastInteractionTimeRef = useRef(Date.now());
    const patrolTimeoutRef = useRef(null);
    const idleTimeoutRef = useRef(null);
    const patrolIntervalRef = useRef(null);
    const isIdle2Ref = useRef(true);

    // Animation names from the GLB file
    const animationNames = {
        idle: 'idle',
        idle2: 'idle2',
        walk: 'walk',
        talk: 'talk',
        wave: 'wave',
        happy: 'happy',
        nod: 'nod',
        shake: 'shake',
        point: 'point',
        dance: 'dance'
    };

    // Global variable to keep track of the current animation action
    let currentAction = null;

    // A function to smoothly transition between animations
    const playAction = useCallback((name, loopMode = THREE.LoopOnce, clampWhenFinished = true, weight = 1.0) => {
        // Stop the current action gracefully
        if (currentAction) {
            currentAction.fadeOut(0.5);
        }

        // Get the new action from the animations map
        const newAction = mixerRef.current.clipAction(animationsRef.current[name]);
        
        // Configure the new action
        newAction.reset();
        newAction.setLoop(loopMode);
        newAction.clampWhenFinished = clampWhenFinished;
        newAction.setEffectiveWeight(weight);
        newAction.fadeIn(0.5);
        newAction.play();

        // Update the current action
        currentAction = newAction;
        return newAction;
    }, []);

    // Function to stop the dance loop and music
    const stopDance = useCallback(() => {
        if (isDancingRef.current) {
            // Stop the dance animation and return to idle
            playAction(animationNames.idle2, THREE.LoopRepeat);
            
            // Stop the music loop
            if (audioLoopRef.current) {
                audioLoopRef.current.stop();
                audioLoopRef.current.dispose();
                audioLoopRef.current = null;
            }
            
            isDancingRef.current = false;
        }
    }, [playAction, animationNames]);


    // Function to handle the dance action
    const handleDance = useCallback(() => {
        // Stop any current movement or patrol
        stopPatrol();
        setIsMoving(false);
        stopIdleTimer();

        if (!isDancingRef.current) {
            // Start the dance animation
            const danceAction = playAction(animationNames.dance, THREE.LoopOnce);

            // Set up a simple musical loop with Tone.js
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "square" }
            }).toDestination();
            
            const musicLoop = new Tone.Loop(time => {
                synth.triggerAttackRelease(["C4", "E4", "G4", "B4"], "8n", time);
                synth.triggerAttackRelease(["E4", "G4", "B4", "C5"], "8n", time + Tone.Time("8n").toSeconds());
            }, "4n").start(0);

            // Keep track of the synth and loop to stop them later
            audioSynthRef.current = synth;
            audioLoopRef.current = musicLoop;
            isDancingRef.current = true;
        } else {
            // If already dancing, stop the dance and music
            stopDance();
        }

        // Reset the interaction timer to prevent immediate patrolling
        lastInteractionTimeRef.current = Date.now();
    }, [playAction, animationNames, stopDance]);


    // Function to play a greeting animation and text
    const handleGreeting = useCallback(async () => {
        // Stop any movement, patrol, or dance
        setIsMoving(false);
        stopPatrol();
        stopDance();
        stopIdleTimer();

        // Set the avatar to talk
        playAction(animationNames.talk, THREE.LoopOnce);
        setIsSpeaking(true);

        const greetingMessage = 'Hello! I am ready to help.';
        speakText(greetingMessage);
        
        // Add the greeting to the chat history
        setChatHistory(prev => [...prev, { role: 'system', text: greetingMessage }]);

        // Wait for the speech to finish and then go back to idle
        await new Promise(resolve => {
            const checkSpeech = setInterval(() => {
                if (!window.speechSynthesis.speaking) {
                    clearInterval(checkSpeech);
                    resolve();
                }
            }, 100);
        });

        playAction(animationNames.idle2, THREE.LoopRepeat);
        setIsSpeaking(false);
        startIdleTimer();
    }, [animationNames, playAction, stopDance, stopIdleTimer, startIdleTimer]);


    // Function to move the avatar to a new position
    const moveAvatar = useCallback((targetPosition) => {
        // Stop any patrol or dance
        stopPatrol();
        stopDance();
        stopIdleTimer();
        lastInteractionTimeRef.current = Date.now();

        const avatarPosition = avatarRef.current.position;
        
        // Play the walk animation and set the moving state
        playAction(animationNames.walk, THREE.LoopRepeat);
        setIsMoving(true);

        // A simple linear interpolation for smooth movement
        const animateMove = () => {
            if (!isMoving) return;

            const distance = avatarPosition.distanceTo(targetPosition);
            if (distance > 0.1) {
                avatarPosition.lerp(targetPosition, 0.05);
                requestAnimationFrame(animateMove);
            } else {
                // Stop the walking animation and go back to idle
                playAction(animationNames.idle2, THREE.LoopRepeat);
                setIsMoving(false);
                startIdleTimer();
            }
        };

        animateMove();
    }, [animationNames, isMoving, playAction, stopDance, stopIdleTimer, startIdleTimer]);

    // Function to start the patrol behavior
    const startPatrol = useCallback(() => {
        if (!avatarRef.current || isMoving || isDancingRef.current) return;
        
        // Start a loop that moves the avatar to a random point
        patrolIntervalRef.current = setInterval(() => {
            const randomX = (Math.random() - 0.5) * 20;
            const randomZ = (Math.random() - 0.5) * 20;
            const targetPosition = new THREE.Vector3(randomX, 0, randomZ);

            // Make the avatar look at the target before walking
            avatarRef.current.lookAt(targetPosition);

            moveAvatar(targetPosition);
        }, 10000); // Move every 10 seconds
    }, [isMoving, moveAvatar]);


    // Function to stop the patrol
    const stopPatrol = useCallback(() => {
        clearTimeout(patrolTimeoutRef.current);
        clearInterval(patrolIntervalRef.current);
        patrolTimeoutRef.current = null;
        patrolIntervalRef.current = null;
    }, []);

    // Function to stop the idle timer
    const stopIdleTimer = useCallback(() => {
        clearTimeout(idleTimeoutRef.current);
        idleTimeoutRef.current = null;
        isIdle2Ref.current = true;
    }, []);
    
    // Function to start the idle timer sequence
    const startIdleTimer = useCallback(() => {
        stopIdleTimer(); // Clear any existing timer
        stopPatrol(); // Make sure patrol is off

        // First timer: 10 seconds to switch from idle2 to idle
        idleTimeoutRef.current = setTimeout(() => {
            if (!isDancingRef.current && !isMoving) {
                playAction(animationNames.idle, THREE.LoopRepeat);
                isIdle2Ref.current = false;

                // Second timer: 20 seconds to start patrol
                patrolTimeoutRef.current = setTimeout(() => {
                    if (!isDancingRef.current && !isMoving) {
                        startPatrol();
                    }
                }, 20000);
            }
        }, 10000);
    }, [playAction, animationNames, startPatrol, stopIdleTimer, stopPatrol]);


    // Effect to handle the autonomous patrol behavior
    useEffect(() => {
        const checkIdle = () => {
            const now = Date.now();
            // If the avatar is not moving, dancing, and has been idle for a while, start the idle timer sequence
            if (!isMoving && !isDancingRef.current && (now - lastInteractionTimeRef.current > 1000)) {
                if (!idleTimeoutRef.current && isIdle2Ref.current) {
                    startIdleTimer();
                }
            } else {
                // If the avatar is active, reset the timers
                stopIdleTimer();
                stopPatrol();
            }
        };

        const idleInterval = setInterval(checkIdle, 1000);
        return () => clearInterval(idleInterval);
    }, [isMoving, startPatrol, stopPatrol, startIdleTimer, stopIdleTimer]);


    // Speak function using the browser's TTS API
    const speakText = (text) => {
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Find a male voice for the avatar if available
        const voices = window.speechSynthesis.getVoices();
        const maleVoice = voices.find(voice => voice.name.includes('male') || voice.name.includes('Male'));
        if (maleVoice) {
            utterance.voice = maleVoice;
        }

        window.speechSynthesis.speak(utterance);
    };


    // Function to handle the chat input
    const handleChat = useCallback(async (prompt) => {
        if (!prompt.trim()) return;

        // Stop any existing animation, patrol, or dance
        stopPatrol();
        stopDance();
        stopIdleTimer();

        // Update chat history with user's message
        setChatHistory(prev => [...prev, { role: 'user', text: prompt }]);
        setIsThinking(true);
        lastInteractionTimeRef.current = Date.now();

        // Play the talking animation
        const talkAction = playAction(animationNames.talk, THREE.LoopOnce);
        setIsSpeaking(true);

        try {
            // API call to the Gemini 2.5 Flash model
            const chatHistoryForAPI = chatHistory.map(chat => ({ role: chat.role, parts: [{ text: chat.text }] }));
            chatHistoryForAPI.push({ role: 'user', parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistoryForAPI,
            };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I couldn\'t generate a response.';
            
            // Add the bot's response to the chat history and speak it
            setChatHistory(prev => [...prev, { role: 'system', text }]);
            speakText(text);

            // Wait for the speech to finish before returning to idle
            await new Promise(resolve => {
                const checkSpeech = setInterval(() => {
                    if (!window.speechSynthesis.speaking) {
                        clearInterval(checkSpeech);
                        resolve();
                    }
                }, 100);
            });

        } catch (error) {
            console.error('Error generating content:', error);
            const errorMessage = 'An error occurred. Please try again.';
            setChatHistory(prev => [...prev, { role: 'system', text: errorMessage }]);
            speakText(errorMessage);
        } finally {
            setIsThinking(false);
            setIsSpeaking(false);
            // After talking, go back to the idle state
            playAction(animationNames.idle2, THREE.LoopRepeat);
            lastInteractionTimeRef.current = Date.now();
            startIdleTimer();
        }
    }, [chatHistory, playAction, animationNames, stopDance, stopPatrol, stopIdleTimer, startIdleTimer]);


    // Function to handle speech recognition
    const handleSpeechRecognition = useCallback(() => {
        // Check for browser support
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            setMessage('Your browser does not support Speech Recognition. Please use Chrome.');
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.interimResults = false;
        recognition.lang = 'en-US';

        setIsListening(true);
        setMessage('Listening...');

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            setInputValue(transcript);
            handleChat(transcript);
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            setMessage(`Error: ${event.error}`);
            setIsListening(false);
        };

        recognition.onend = () => {
            setIsListening(false);
            setMessage(null);
        };

        recognition.start();
    }, [handleChat]);


    // Main useEffect for setting up the Three.js scene and avatar
    useEffect(() => {
        const currentMount = mountRef.current;
        const width = currentMount.clientWidth;
        const height = currentMount.clientHeight;

        // --- SCENE SETUP ---
        const setupScene = () => {
            renderer.current.setSize(width, height);
            renderer.current.setPixelRatio(window.devicePixelRatio);
            renderer.current.shadowMap.enabled = true;
            currentMount.appendChild(renderer.current.domElement);

            camera.current.position.set(0, 2, 5);
            scene.current.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.current.add(directionalLight);

            // Ground plane
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const ground = new THREE.Mesh(planeGeometry, planeMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.current.add(ground);
        };

        // --- AVATAR LOADING ---
        const loadAvatar = () => {
            const loader = new GLTFLoader();
            loader.load(
                'https://models.readyplayer.me/65c8266228399a0a03004313.glb',
                (gltf) => {
                    const avatar = gltf.scene;
                    avatarRef.current = avatar;
                    avatar.scale.set(1.5, 1.5, 1.5);
                    avatar.position.y = 0.5;
                    avatar.castShadow = true;
                    avatar.receiveShadow = true;
                    scene.current.add(avatar);

                    // Initialize the animation mixer
                    mixerRef.current = new THREE.AnimationMixer(avatar);
                    gltf.animations.forEach(clip => {
                        animationsRef.current[clip.name] = clip;
                    });
                    
                    // Add an event listener for animation finish
                    mixerRef.current.addEventListener('finished', (e) => {
                        // Check if the finished animation was the dance
                        if (e.action === currentAction && e.action.getClip().name === animationNames.dance) {
                            stopDance();
                            playAction(animationNames.idle2, THREE.LoopRepeat);
                            startIdleTimer();
                        }
                    });

                    // Play the default idle animation
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                    setIsAvatarLoaded(true);
                    
                    // Initialize look-at behavior for head/eyes
                    setupLookAtBehavior(avatar);
                    startIdleTimer();
                },
                (xhr) => {
                    console.log(`Avatar loading: ${(xhr.loaded / xhr.total) * 100}% loaded`);
                },
                (error) => {
                    console.error('An error happened loading the avatar:', error);
                }
            );
        };

        // --- LOOK-AT BEHAVIOR ---
        const setupLookAtBehavior = (avatar) => {
            let neck = null;
            let head = null;
            avatar.traverse(o => {
                if (o.isBone) {
                    if (o.name === "Neck") neck = o;
                    if (o.name === "Head") head = o;
                }
            });
            if (neck && head) {
                const headBone = head;
                const neckBone = neck;
                const targetQuaternion = new THREE.Quaternion();
                const originalHeadQuaternion = headBone.quaternion.clone();
                const originalNeckQuaternion = neckBone.quaternion.clone();

                const onPointerMove = (event) => {
                    if (!lookAtMouseRef.current) return;
                    mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1;
                };

                const updateLookAt = () => {
                    if (!lookAtMouseRef.current || isSpeaking || isMoving) {
                        // Reset head and neck rotation if not looking at mouse
                        headBone.quaternion.slerp(originalHeadQuaternion, 0.1);
                        neckBone.quaternion.slerp(originalNeckQuaternion, 0.1);
                        return;
                    }

                    // Calculate the position to look at based on the mouse
                    const vector = new THREE.Vector3(mouse.current.x, mouse.current.y, 1);
                    vector.unproject(camera.current);
                    vector.sub(headBone.position).normalize();

                    // Apply a limited rotation to the head and neck
                    const headLimit = Math.PI * 0.15; // 15 degrees
                    const neckLimit = Math.PI * 0.1; // 10 degrees

                    headBone.lookAt(vector);
                    neckBone.lookAt(vector);

                    // Clamp the rotation
                    headBone.quaternion.slerp(originalHeadQuaternion, 0.5);
                    neckBone.quaternion.slerp(originalNeckQuaternion, 0.5);
                };
                
                window.addEventListener('pointermove', onPointerMove);
                // Call updateLookAt in the animation loop
                const animateLookAt = () => {
                    updateLookAt();
                    requestAnimationFrame(animateLookAt);
                };
                animateLookAt();
            }
        };


        // --- EVENT LISTENERS AND ANIMATION LOOP ---
        const onWindowResize = () => {
            camera.current.aspect = window.innerWidth / window.innerHeight;
            camera.current.updateProjectionMatrix();
            renderer.current.setSize(window.innerWidth, window.innerHeight);
        };

        const onPointerDown = (event) => {
            if (!isAvatarLoaded) return;
            // Normalize mouse coordinates
            mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Cast a ray from the camera to the mouse position
            raycaster.current.setFromCamera(mouse.current, camera.current);
            const intersects = raycaster.current.intersectObject(scene.current.children, true);
            
            if (intersects.length > 0) {
                const firstIntersect = intersects[0];
                // Check if the click was on the ground
                if (firstIntersect.object.geometry instanceof THREE.PlaneGeometry) {
                    moveAvatar(firstIntersect.point);
                }
                // Check if the click was on the avatar itself
                if (firstIntersect.object.parent && firstIntersect.object.parent.uuid === avatarRef.current.uuid) {
                    handleGreeting();
                }
            }
            lastInteractionTimeRef.current = Date.now();
        };

        const animate = () => {
            requestAnimationFrame(animate);
            const delta = clockRef.current.getDelta();
            if (mixerRef.current) {
                mixerRef.current.update(delta);
            }
            // Update lookAt behavior
            lookAtMouseRef.current = !isMoving && !isSpeaking;
            if (lookAtMouseRef.current) {
                 // A simple way to make the head follow the mouse for now
                 if (avatarRef.current) {
                    const vector = new THREE.Vector3(mouse.current.x, mouse.current.y, 1);
                    vector.unproject(camera.current);
                    const headBone = avatarRef.current.getObjectByName('Head');
                    if (headBone) {
                         headBone.lookAt(vector);
                    }
                 }
            }
            renderer.current.render(scene.current, camera.current);
        };
        
        setupScene();
        loadAvatar();

        controls.current = new OrbitControls(camera.current, renderer.current.domElement);
        controls.current.target.set(0, 1.5, 0);
        controls.current.update();

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('pointerdown', onPointerDown);

        // This is a new event listener for the animation mixer
        if (mixerRef.current) {
            mixerRef.current.addEventListener('finished', (e) => {
                // If the dance animation finished, stop the music and go back to idle
                if (isDancingRef.current && e.action.getClip().name === animationNames.dance) {
                    stopDance();
                    playAction(animationNames.idle2, THREE.LoopRepeat);
                    startIdleTimer();
                }
            });
        }

        animate();

        return () => {
            // Cleanup on component unmount
            currentMount.removeChild(renderer.current.domElement);
            window.removeEventListener('resize', onWindowResize);
            window.removeEventListener('pointerdown', onPointerDown);
            if (mixerRef.current) {
                mixerRef.current.stopAllAction();
            }
            stopDance();
            stopPatrol();
            stopIdleTimer();
        };
    }, [playAction, animationNames, handleDance, handleGreeting, handleChat, moveAvatar, isMoving, startPatrol, stopPatrol, stopDance, startIdleTimer, stopIdleTimer]);

    return (
        <div className="flex h-screen w-screen bg-gray-900 text-white">
            <div className="flex-grow flex flex-col items-center justify-center p-4 relative" ref={mountRef}>
                {message && (
                    <div className="absolute top-4 bg-yellow-500 text-yellow-900 px-4 py-2 rounded-lg font-bold z-50">
                        {message}
                    </div>
                )}
            </div>
            
            <div className="w-1/4 max-w-sm bg-gray-800 p-4 flex flex-col h-full rounded-l-lg shadow-xl">
                <h2 className="text-xl font-bold mb-4">Chat</h2>
                <div className="flex-grow overflow-y-auto space-y-4 pr-2 mb-4">
                    {chatHistory.map((msg, index) => (
                        <div key={index} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                            <div className={`p-3 rounded-xl max-w-[80%] ${msg.role === 'user' ? 'bg-blue-600' : 'bg-gray-700'}`}>
                                {msg.text}
                            </div>
                        </div>
                    ))}
                </div>
                
                <div className="flex gap-2">
                    <input
                        type="text"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                        placeholder="Type a message..."
                        className="flex-grow p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                                handleChat(inputValue);
                                setInputValue('');
                            }
                        }}
                        disabled={isThinking || isSpeaking || isListening}
                    />
                    <button
                        onClick={() => {
                            handleChat(inputValue);
                            setInputValue('');
                        }}
                        className="bg-blue-600 text-white p-3 rounded-lg font-bold hover:bg-blue-700 transition-colors duration-200"
                        disabled={isThinking || isSpeaking || isListening || inputValue.trim() === ''}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" />
                        </svg>
                    </button>
                    <button
                        onClick={handleSpeechRecognition}
                        className={`p-3 rounded-lg font-bold transition-colors duration-200 ${isListening ? 'bg-red-500 hover:bg-red-600' : 'bg-green-600 hover:bg-green-700'}`}
                        disabled={isThinking || isSpeaking}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7v0m-7-7a7 7 0 017-7v0m7 7v0a7 7 0 01-7-7m0 7a7 7 0 01-7-7m7 7v0a7 7 0 01-7-7m7 7v0a7 7 0 01-7-7m7-7H3" />
                        </svg>
                    </button>
                </div>

                <div className="flex justify-center mt-4">
                    <button
                        onClick={handleDance}
                        className="bg-purple-600 text-white p-3 rounded-lg font-bold hover:bg-purple-700 transition-colors duration-200"
                        disabled={isThinking || isSpeaking || isMoving}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M4 4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-3.293l-1.147-1.146a.5.5 0 00-.707 0L9.293 4H4zm10.586 2l1.147-1.146a.5.5 0 01.707 0L17 5.293V6h-2.586zM10 9a3 3 0 100 6 3 3 0 000-6z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    );
}
