<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-AVATAR</title>

    <!-- Tailwind CSS for utility styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader to load 3D models and animations -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Tone.js for web audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        /* General body styling and font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background: #111827;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        /* Canvas styling to fill the screen */
        canvas {
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        /* Loading screen styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1f2937;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        /* Spinner animation for the loading screen */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Chat UI container styles */
        .chat-ui-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            top: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            background-color: rgba(31, 41, 55, 0.9);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Responsive styles for mobile */
        @media (max-width: 768px) {
            .chat-ui-container {
                position: fixed;
                bottom: 0;
                left: 0;
                top: auto;
                height: 50%;
                max-width: 100%;
                border-radius: 1rem 1rem 0 0;
            }
        }

        /* Chat history area styles */
        .chat-history {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
            padding: 0.5rem;
            margin-bottom: 1rem;
            -webkit-overflow-scrolling: touch; /* for smooth scrolling on iOS */
        }
        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
        }
        .user-message {
            background-color: #2563eb;
            color: white;
            align-self: flex-end;
            border-top-right-radius: 0;
        }
        .ai-message {
            background-color: #4b5563;
            color: white;
            align-self: flex-start;
            border-top-left-radius: 0;
        }

        /* Chat input area and buttons */
        .chat-input-area {
            display: flex;
            gap: 0.5rem;
        }
        .input-field {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 9999px;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: white;
        }
        .icon-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: #2563eb;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .icon-button:hover {
            background-color: #1d4ed8;
        }
        .icon-button:active {
            transform: scale(0.95);
        }
        .pulse {
            animation: pulse-animation 1s infinite;
        }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(37, 99, 235, 0); }
            100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
        }
        
        /* Control buttons container */
        .controls-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 1rem;
        }

        /* Modal styles for messages */
        .modal {
            position: fixed;
            inset: 0;
            background-color: rgba(31, 41, 55, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        .modal-content {
            background-color: #374151;
            color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-width: 24rem;
            width: 90%;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="spinner mb-4"></div>
        <p id="loading-text" class="text-xl">Loading... 0%</p>
    </div>

    <!-- 3D Canvas -->
    <canvas id="avatar-canvas"></canvas>

    <!-- Chat and Controls UI -->
    <div id="chat-ui-container" class="chat-ui-container">
        <h1 class="text-white text-2xl font-bold mb-4">AI Avatar Chat</h1>
        <div id="chat-history" class="chat-history"></div>
        <div class="chat-input-area">
            <input id="chat-input" type="text" placeholder="Type a message..." class="input-field">
            <button id="mic-button" class="icon-button">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="send-button" class="icon-button">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
    <div class="controls-container">
        <button id="dance-button" class="icon-button w-12 h-12">
            <i class="fas fa-music"></i>
        </button>
    </div>
    
    <!-- Modal for messages -->
    <div id="message-modal" class="modal">
        <div class="modal-content">
            <p id="modal-message" class="mb-4"></p>
            <div class="flex justify-end">
                <button id="modal-close" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Global variables and constants
        // Using a single, publicly available and reliable model with multiple animations
        const avatarUrl = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';
        const GEMINI_API_KEY = "AIzaSyCWaPLRukI_Rhb8vB29vVjEk5GEuopXnA4";
        const GEMINI_FLASH_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
        const GEMINI_TTS_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_API_KEY}`;
        
        // State variables
        let scene, camera, renderer, avatar, mixer;
        let animations = {};
        let currentAction;
        let clock = new THREE.Clock();
        let chatHistory = [];
        let isMoving = false;
        let isThinking = false;
        let isTalking = false;
        let isDancing = false;
        let isListening = false;
        let isWaving = false;
        let isPatrolling = false;
        let lastInteractionTime = Date.now();
        
        // Idle and Patrol timings from user requirements
        const passiveIdleTimeout = 10000; // 10 seconds of no interaction for passive idle
        const patrolTimeout = 30000; // 30 seconds of no interaction for patrol mode
        const patrolWaitTime = 10000; // 10 seconds wait at each patrol point
        
        let patrolTimer, idleTimer; // Timers for the idle/patrol sequence
        
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let speechRecognition;
        let jawBone;
        let headBone;

        // Tone.js setup for dance music
        let synth = new Tone.PolySynth().toDestination();
        let danceLoop;

        // UI elements
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const chatHistoryEl = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const danceButton = document.getElementById('dance-button');
        const modal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalClose = document.getElementById('modal-close');
        
        // Greetings from user requirements
        const greetings = [
            { initial: "Hello there!", followUp: "What can I do for you?" },
            { initial: "Hi!", followUp: "How can I help?" },
            { initial: "Hey!", followUp: "Nice to see you!" },
            { initial: "Greetings!", followUp: "Feel free to ask me anything." }
        ];

        // Helper functions
        function showModal(message) {
            modalMessage.textContent = message;
            modal.style.display = 'flex';
        }
        modalClose.addEventListener('click', () => {
            modal.style.display = 'none';
        });
        
        function addMessage(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender === 'User' ? 'user-message' : 'ai-message'}`;
            messageElement.textContent = text;
            chatHistoryEl.prepend(messageElement);
        }

        // Web Speech Recognition setup
        if ('webkitSpeechRecognition' in window) {
            speechRecognition = new webkitSpeechRecognition();
            speechRecognition.continuous = false;
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';

            speechRecognition.onstart = () => {
                isListening = true;
                micButton.classList.add('pulse');
                console.log("Listening...");
            };

            speechRecognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                chatInput.value = transcript;
                handleChat(transcript);
            };

            speechRecognition.onend = () => {
                isListening = false;
                micButton.classList.remove('pulse');
                console.log("Listening ended.");
                if (!isTalking && !isThinking && !isDancing) {
                    playAction('Idle', THREE.LoopRepeat);
                }
            };

            speechRecognition.onerror = (event) => {
                console.error("Speech recognition error", event.error);
                isListening = false;
                micButton.classList.remove('pulse');
                handleError();
                showModal(`Speech recognition error: ${event.error}`);
            };
        } else {
            console.warn("Web Speech Recognition is not supported in this browser.");
            micButton.style.display = 'none';
        }

        // Initialize the 3D scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);
            camera.lookAt(new THREE.Vector3(0, 1.2, 0));

            renderer = new THREE.WebGLRenderer({ antialiasing: true, canvas: document.getElementById('avatar-canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 5, 3);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            loadAssets();
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
        }

        // Load avatar model and all animations
        async function loadAssets() {
            const loader = new THREE.GLTFLoader();
            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(avatarUrl, (loadedGltf) => {
                        if (!loadedGltf) {
                            reject(new Error("Loaded GLTF is null or undefined."));
                        }
                        resolve(loadedGltf);
                    }, xhr => {
                        loadingText.textContent = `Loading... ${Math.round((xhr.loaded / xhr.total) * 100)}%`;
                    }, (error) => {
                        console.error('An error occurred loading the models:', error);
                        reject(new Error("Failed to load model. Please check the URL and network."));
                    });
                });

                avatar = gltf.scene;
                avatar.scale.set(0.5, 0.5, 0.5); // Adjust scale for the new model
                avatar.position.y = -0.01;
                avatar.castShadow = true;
                scene.add(avatar);
                mixer = new THREE.AnimationMixer(avatar);
                
                // Map the glTF animations to our custom names based on user's requirements
                animations['idle2'] = gltf.animations.find(clip => clip.name === 'Idle'); // Active idle
                animations['idle'] = gltf.animations.find(clip => clip.name === 'Idle'); // Passive idle (using same for now)
                animations['walk'] = gltf.animations.find(clip => clip.name === 'Walking');
                animations['dance'] = gltf.animations.find(clip => clip.name === 'Dance');
                animations['wave'] = gltf.animations.find(clip => clip.name === 'Waving');
                animations['talk'] = gltf.animations.find(clip => clip.name === 'Talking');
                animations['think'] = gltf.animations.find(clip => clip.name === 'Thinking');
                animations['shake'] = gltf.animations.find(clip => clip.name === 'Excited'); // Using Excited as a shake stand-in
                animations['listening'] = gltf.animations.find(clip => clip.name === 'Idle'); // Using Idle as a stand-in for listening

                if (!animations['idle2']) {
                    throw new Error("Could not find 'Idle' animation in the model. Model may be incompatible.");
                }

                // Find bones for interaction
                avatar.traverse(o => {
                    if (o.isBone) {
                        if (o.name === 'Head') headBone = o;
                        if (o.name === 'Jaw') jawBone = o;
                    }
                });

                loadingScreen.style.opacity = 0;
                setTimeout(() => loadingScreen.style.display = 'none', 1000);
                
                startGreetingSequence();
                setupInteractions();
                animate();

            } catch (error) {
                console.error('An error occurred loading the models:', error);
                showModal('Error loading avatar assets: ' + error.message);
            }
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);

            if (isTalking) {
                lipSync();
            }

            if (!isMoving && !isDancing && !isTalking && !isListening) {
                checkIdlePatrol();
            }

            if (isMoving) {
                updateAvatarMovement(delta);
            }

            mouseLook();
            renderer.render(scene, camera);
        }

        // Avatar movement logic
        function updateAvatarMovement(delta) {
            const distance = avatar.position.distanceTo(avatar.userData.targetPosition);
            if (distance > 0.05) {
                const direction = new THREE.Vector3().subVectors(avatar.userData.targetPosition, avatar.position);
                direction.y = 0;
                direction.normalize();
                
                const moveSpeed = 0.02;
                avatar.position.addScaledVector(direction, moveSpeed);

                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(0, 0, 1),
                    direction.clone().normalize()
                );
                avatar.quaternion.slerp(targetQuaternion, 0.1);

            } else {
                avatar.position.copy(avatar.userData.targetPosition);
                isMoving = false;
                playAction('idle2', THREE.LoopRepeat);
                lastInteractionTime = Date.now();
            }
        }

        // Lipsync logic
        function lipSync() {
            if (!jawBone) return;
            const time = performance.now() * 0.001;
            const jawRotation = Math.sin(time * 15) * 0.05 + 0.02;
            jawBone.rotation.x = -jawRotation;
        }

        // Mouse look logic
        function mouseLook() {
            if (!headBone) return;
            const target = new THREE.Vector3(mouse.x * 0.5, mouse.y * 0.5 + 1.2, -1);
            target.y += 0.5;
            headBone.lookAt(target);
        }

        // Animation playback and state management
        function playAction(clipName, loopMode = THREE.LoopOnce) {
            if (!mixer) return;
            const clip = animations[clipName];
            if (!clip) {
                console.warn(`Animation clip '${clipName}' not found. Playing idle2 instead.`);
                playAction('idle2', THREE.LoopRepeat);
                return;
            }
            const newAction = mixer.clipAction(clip);
            newAction.setEffectiveWeight(1);
            if (currentAction) {
                newAction.crossFadeFrom(currentAction, 0.3);
            }
            newAction.loop = loopMode;
            if (loopMode === THREE.LoopOnce) {
                newAction.clampWhenFinished = true;
            }
            newAction.play();
            currentAction = newAction;
        }

        function stopAllActions() {
            if (currentAction) {
                currentAction.stop();
            }
        }
        
        // --- Patrolling and Idle behavior ---
        function resetIdleSequence() {
            lastInteractionTime = Date.now();
            isPatrolling = false;
            clearTimeout(patrolTimer);
            clearTimeout(idleTimer);
            if (!isTalking && !isThinking && !isDancing && !isListening) {
                playAction('idle2', THREE.LoopRepeat);
            }
        }

        function startPatrolCycle() {
            if (!isPatrolling) return;
            
            const randomX = (Math.random() - 0.5) * 10;
            const randomZ = (Math.random() - 0.5) * 10;
            const targetPosition = new THREE.Vector3(randomX, 0, randomZ);
            
            moveAvatar(targetPosition);

            patrolTimer = setTimeout(() => {
                if (isPatrolling) {
                    startPatrolCycle();
                }
            }, patrolWaitTime); // Wait 10 seconds at each point
        }

        function checkIdlePatrol() {
            const inactivityTime = Date.now() - lastInteractionTime;
            
            if (inactivityTime > patrolTimeout) {
                if (!isPatrolling) {
                    isPatrolling = true;
                    startPatrolCycle();
                }
            } else if (inactivityTime > passiveIdleTimeout) {
                if (currentAction.getClip().name !== animations['idle'].name) {
                    playAction('idle', THREE.LoopRepeat);
                }
            } else {
                if (currentAction.getClip().name !== animations['idle2'].name) {
                    playAction('idle2', THREE.LoopRepeat);
                }
            }
        }

        // --- Interaction Handlers ---
        function reactToInteraction() {
            resetIdleSequence();
            isMoving = false;
            // Face the camera immediately
            faceCamera();
        }

        // Event listeners
        function setupInteractions() {
            const ground = scene.children.find(obj => obj.geometry.type === 'PlaneGeometry');

            document.getElementById('avatar-canvas').addEventListener('click', (event) => {
                reactToInteraction();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersectsAvatar = raycaster.intersectObject(avatar, true);
                if (intersectsAvatar.length > 0) {
                    handleGreeting();
                    return;
                }
                
                const groundIntersects = raycaster.intersectObject(ground);
                if (groundIntersects.length > 0) {
                    moveAvatar(groundIntersects[0].point);
                }
            });

            document.getElementById('chat-ui-container').addEventListener('click', (event) => {
                reactToInteraction();
                handleGreeting();
            });

            chatInput.addEventListener('focus', () => {
                reactToInteraction();
                handleGreeting();
            });

            sendButton.addEventListener('click', () => handleChat(chatInput.value));
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleChat(chatInput.value);
                }
            });
            micButton.addEventListener('click', handleMic);
            danceButton.addEventListener('click', handleDance);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function faceCamera() {
            if (!avatar) return;
            const cameraPosition = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
            avatar.lookAt(cameraPosition.x, avatar.position.y, cameraPosition.z);
        }

        function moveAvatar(target) {
            reactToInteraction();
            isMoving = true;
            avatar.userData.targetPosition = target;
            playAction('walk', THREE.LoopRepeat);
        }

        async function handleGreeting() {
            reactToInteraction();
            isWaving = true;
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            
            playAction('wave', THREE.LoopOnce);
            await speak(randomGreeting.initial);

            isWaving = false;
            playAction('talk', THREE.LoopRepeat);
            await speak(randomGreeting.followUp);

            playAction('idle2', THREE.LoopRepeat);
        }

        function handleMic() {
            reactToInteraction();
            if (speechRecognition) {
                if (isListening) {
                    speechRecognition.stop();
                } else {
                    playAction('talk', THREE.LoopRepeat);
                    speak("Go ahead, I'm listening.", () => {
                        playAction('listening', THREE.LoopRepeat);
                        speechRecognition.start();
                    });
                }
            }
        }
        
        async function handleChat(prompt) {
            reactToInteraction();
            prompt = prompt.trim();
            if (!prompt) return;

            addMessage('User', prompt);
            chatInput.value = '';

            isThinking = true;
            playAction('think', THREE.LoopRepeat);

            // Handle "dance" trigger from chat
            if (prompt.toLowerCase().includes('dance')) {
                isThinking = false;
                handleDance();
                return;
            }

            try {
                const chatPayload = { contents: [...chatHistory, { role: "user", parts: [{ text: prompt }] }] };
                const response = await fetch(GEMINI_FLASH_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(chatPayload)
                });
                if (!response.ok) throw new Error('API request failed');
                const result = await response.json();

                isThinking = false;
                if (result.candidates && result.candidates.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    chatHistory.push({ role: "model", parts: [{ text: text }] });
                    addMessage('Avatar', text);
                    await speak(text);
                } else {
                    handleError();
                }
            } catch (error) {
                console.error('Error with Gemini API:', error);
                handleError();
            } finally {
                if (!isTalking && !isDancing) {
                    playAction('idle2', THREE.LoopRepeat);
                }
            }
        }

        async function speak(text, onendedCallback = () => {}) {
            isTalking = true;
            if (currentAction.getClip().name !== animations['talk'].name) {
                playAction('talk', THREE.LoopRepeat);
            }
            
            try {
                const ttsPayload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } } },
                    model: "gemini-2.5-flash-preview-tts"
                };
                const response = await fetch(GEMINI_TTS_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ttsPayload)
                });
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();
                    audio.onended = () => {
                        isTalking = false;
                        lastInteractionTime = Date.now();
                        if (!isDancing) {
                            playAction('idle2', THREE.LoopRepeat);
                        }
                        onendedCallback();
                    };
                } else {
                    throw new Error('TTS response missing audio data');
                }
            } catch (error) {
                console.error("Error with TTS:", error);
                isTalking = false;
                handleError();
            }
        }

        function handleError() {
            playAction('shake', THREE.LoopOnce);
            showModal("An error occurred. Please try again.");
            if (animations['shake']) {
                mixer.addEventListener('finished', (e) => {
                    if (e.action._clip.name === animations['shake'].name) {
                        playAction('idle2', THREE.LoopRepeat);
                    }
                }, { once: true });
            } else {
                playAction('idle2', THREE.LoopRepeat);
            }
        }

        // --- Dance Mode Logic ---
        function startDanceMusic() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            // A simple, catchy beat
            danceLoop = new Tone.Loop(time => {
                const notes = ['C4', 'E4', 'G4'];
                const note = notes[Math.floor(Math.random() * notes.length)];
                synth.triggerAttackRelease(note, '8n', time);
            }, '4n').start(0);
            Tone.Transport.start();
        }

        function stopDanceMusic() {
            if (danceLoop) {
                danceLoop.stop();
                danceLoop = null;
            }
            Tone.Transport.stop();
        }

        function handleDance() {
            reactToInteraction();
            isDancing = true;
            playAction('dance', THREE.LoopOnce);
            startDanceMusic();
            
            if (animations['dance']) {
                mixer.addEventListener('finished', (e) => {
                    if (e.action._clip.name === animations['dance'].name) {
                        stopDance();
                    }
                }, { once: true });
            } else {
                stopDance();
            }
        }
        
        function stopDance() {
            isDancing = false;
            stopDanceMusic();
            playAction('idle2', THREE.LoopRepeat);
        }
        
        // Audio helper functions
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const wavData = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(wavData);
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, 1, true); // Mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        window.onload = init;
    </script>
</body>
</html>
